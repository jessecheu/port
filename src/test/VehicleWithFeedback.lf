/**
 * The main menu for the Cargo Vehicle built upon the Pololu 3pi+ rp2040 Robot. 
 * Allows to switch the drive mode, stop mode, and other modes.
 */
 target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Line from "../lib/Line.lf"
import Display from "../lib/Display.lf"
import Motors from "../lib/Motors.lf"
import GyroAngle from "../lib/IMU.lf"
import Encoders from "../lib/Encoders.lf"
import Buttons from "../lib/Buttons.lf"

reactor AngleToDistance {
  input degrees:int32_t
  output distance:float

  reaction(degrees) -> distance {=
    lf_set(distance, degrees->value*(9.975/360)); //cm units
  =}

}

main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
  preamble {=

  =}

  line = new Line()
  disp = new Display()
  motor = new Motors()
  gyro = new GyroAngle()
  encoder = new Encoders()
  buttons = new Buttons();
  angleToDistance = new AngleToDistance();


  timer t(0, sample_period)
  timer trigger_time(0, 150 ms);
  timer seconds(0, 1 s)
  
  //Calibration Related
  timer end_calibration(calibration_time)
  state calibration_startup: bool = true
  state calibration_time_count: int = 0

  state angle_before_turn: float = 0
  state button_press_time: int = 0

  //Driving Related
  state pid_previous_error: float = 0

  //Cargo Related 
  state moving_forward_step_timer: int = 0

  reaction(trigger_time) -> line.trigger, buttons.trigger, gyro.trigger, encoder.trigger {=
    lf_set(line.trigger, true);
    lf_set(buttons.trigger, true);
    lf_set(gyro.trigger, true);
    lf_set(encoder.trigger, true);
  =}

  reaction(encoder.left) -> angleToDistance.degrees {=
    lf_set(angleToDistance.degrees, encoder.left->value);
  =}


  initial mode MAIN_MENU_MODE {
      //Menu for the Cargo 
      //Uses Buttons to control which mode to be in.
      reaction(t) -> disp.line0, disp.line1, disp.line2, disp.line3, motor.left_power, motor.right_power{= 
        static char buf0[17];
        static char buf1[17];
        static char buf2[17];
        static char buf3[17];
        snprintf(buf0, 17, "[A]: Calibration Mode");
        snprintf(buf1, 17, "[B]: DRIVE Mode");
        snprintf(buf2, 17, "[C]: .... Extra");
        snprintf(buf3, 17, " ");
        lf_set(motor.left_power, 0);
        lf_set(motor.right_power, 0);
        lf_set(disp.line0, buf0);
        lf_set(disp.line1, buf1);
        lf_set(disp.line2, buf2);
        lf_set(disp.line3, buf3);
      =}

      //Checking buttons
      reaction(buttons.button_a, buttons.button_b, buttons.button_c) -> CALIBRATION_MODE, DRIVE_MODE, EXTRA_MODE, motor.left_power, motor.right_power {=
        if (buttons.button_a->value) {
          lf_set_mode(CALIBRATION_MODE);
        } else if (buttons.button_b->value) {
          lf_set(motor.left_power, 0.075f);
          lf_set(motor.right_power, 0.075f);
          lf_set_mode(DRIVE_MODE);
        } else if (buttons.button_c->value) {
          lf_set_mode(EXTRA_MODE);
        }
      =}
  }

  mode CALIBRATION_MODE { 
    /* Going back to the main menu */
    reaction(buttons.button_c) -> MAIN_MENU_MODE {=
      if(buttons.button_c->value) {
        self->calibration_startup = true; //Resetting the calibration values
        self->calibration_time_count = 0;
        lf_set_mode(MAIN_MENU_MODE);
      }
    =}

    /* Entering the Calibration mode and stops it after x amount of seconds*/
    reaction(seconds) -> line.calibrate, disp.line0, disp.line1, disp.line2, disp.line3 {=
      if (self->calibration_startup) {
        lf_set(disp.line0, "CALIBRATING");
        lf_set(disp.line1, "Roll robot over");
        lf_set(disp.line2, "light and dark.");
        static char buf[17];
        snprintf(buf, 17, "time:%8d s", self->calibration_time_count++);
        lf_set(disp.line3, buf);
        lf_set(line.calibrate, true);
        if (self->calibration_time_count > 10) {
          lf_set(line.calibrate, false);
          self->calibration_startup = false;
        }
      }

    =}

    /* After calibration mode, allows for users to see on the LED screen the line encoder values*/
    reaction(line.reflect) -> disp.line0, disp.line1, disp.line2, disp.line3 {=
      static char buf0[17];
      static char buf1[17];
      static char buf2[17];
      static char buf3[17];
      snprintf(buf0, 17, "0:%4d 1:%4d", line.reflect->value[0], line.reflect->value[1]);
      snprintf(buf1, 17, "2:%4d 3:%4d", line.reflect->value[2], line.reflect->value[3]);
      snprintf(buf2, 17, "4:%4d", line.reflect->value[4]);
      snprintf(buf3, 17, "Main Menu: [C]");
      lf_set(disp.line0, buf0);
      lf_set(disp.line1, buf1);
      lf_set(disp.line2, buf2);
      lf_set(disp.line3, buf3);
    =}
  }

  mode DRIVE_MODE {
    reaction(line.reflect) gyro.z, angleToDistance.distance -> ARRIVED_STOP_MODE, motor.left_power, motor.right_power, disp.line0, disp.line1, disp.line2, disp.line3 {= 
      //Logic for driving
      //Printing to the LED Screen
      static char buf0[17];
      static char buf1[17];
      static char buf2[17];
      static char buf3[17];

      snprintf(buf0, 17, "0:%4d 1:%4d", line.reflect->value[0], line.reflect->value[1]);
      snprintf(buf1, 17, "2:%4d 3:%4d", line.reflect->value[2], line.reflect->value[3]);
      snprintf(buf2, 17, "4:%4d", line.reflect->value[4]);
      snprintf(buf3, 17, "gyro.z: %f", gyro.z->value);

      //Stops the Vehicle if the ARRIVAL STOP lines are detected
      uint32_t ARRIVAL_STOP_LOW_VALUE = 400;
      if (line.reflect->value[0] >= ARRIVAL_STOP_LOW_VALUE
          && line.reflect->value[1] >= ARRIVAL_STOP_LOW_VALUE
          && line.reflect->value[2] >= ARRIVAL_STOP_LOW_VALUE
          && line.reflect->value[3] >= ARRIVAL_STOP_LOW_VALUE
          && line.reflect->value[4] >= ARRIVAL_STOP_LOW_VALUE) {
            lf_set(motor.left_power, 0);
            lf_set(motor.right_power, 0);
            lf_set_mode(ARRIVED_STOP_MODE);
      }

      //Robot: Aim to keep the robot moving forward by 
      //using the center line sensor which is line[2] and PID Control

      //Driving Related - PID Controller Variable Declarations
      float current_error = 1000 - line.reflect->value[2]  //Expected Sensor value - current Sensor value. 

      float pid_Kp = 0;
      float pid_Ki = 0;
      float pid_Kd = 0;

      float pid_proportional_term_error = 0;
      float pid_integral_term_error = 0;
      float pid_differential_term_error = 0; 

      float pid_proportional_term = pid_Kp * pid_proportional_term_error;
      float pid_integral_term = pid_Ki * pid_integral_term_error;
      float pid_differential_term = pid_Kd * pid_differential_term_error;

      float left_side_motor_power = 0;
      float right_side_motor_power = 0;

      float pid_value = pid_proportional_term + pid_integral_term + pid_differential_term;
      self->pid_previous_error = error;


      //Setting minimum and maximum speed values



      lf_set(motor.left_power, left_side_motor_power);
      lf_set(motor.right_power, right_side_motor_power);
      lf_set(disp.line0, buf0);
      lf_set(disp.line1, buf1);
      lf_set(disp.line2, buf2);
      lf_set(disp.line3, buf3);
    =} 

    reaction(buttons.button_a, buttons.button_b, buttons.button_c) -> MAIN_MENU_MODE, motor.left_power, motor.right_power {=
      if (buttons.button_c->value) {
        lf_set(motor.left_power, 0);
        lf_set(motor.right_power, 0);
        lf_set_mode(MAIN_MENU_MODE);
      } 
    =}
  }

  mode ARRIVED_STOP_MODE {
    //Temporarily pauses the vehicle. Entered by the DRIVE mode.
    reaction(t) -> motor.left_power, motor.right_power, disp.line0, disp.line1, disp.line2,disp.line3 {=
      //gyro.z = -90, angle_before_turn = -10, result = -80
      lf_set(motor.left_power, 0);
      lf_set(motor.right_power, 0);
      lf_set(disp.line0, "ARRIVED STOP MODE");
      lf_set(disp.line1, " ");
      lf_set(disp.line2, " ");
      lf_set(disp.line3, "CONTINUE = [C]");
    =}

    //Checking buttons
    reaction(buttons.button_a, buttons.button_b, buttons.button_c) -> MOVE_FORWARD, motor.left_power, motor.right_power {=
      if (buttons.button_c->value) {
        lf_set(motor.left_power, 0.1f);
        lf_set(motor.right_power, 0.1f);
        lf_set_mode(MOVE_FORWARD);
      } 
    =}
  }

  mode MOVE_FORWARD { 
    reaction(t) line.reflect, gyro.z -> DRIVE_MODE, motor.left_power, motor.right_power, disp.line0, disp.line1, disp.line2,disp.line3 {= 
      lf_set(disp.line0, "Moving Foward");
      lf_set(disp.line1, "for 1 and half seconds");
      lf_set(disp.line2, "then goes to");
      lf_set(disp.line3, "Main Menu");

      if (self->moving_forward_step_timer >= 10) { 
        self->moving_forward_step_timer = 0;
        lf_set(motor.left_power, 0.1);
        lf_set(motor.right_power, 0.1);
        lf_set_mode(DRIVE_MODE);
      } else {
        //Robot: Aim to keep the robot moving forward by 
        //using the center line sensor which is line[2] using PID Control

        self->moving_forward_step_timer += 1;
      }
    =}
  }

  mode EXTRA_MODE {
    //Extra Menus and options for the car
    reaction(t) -> disp.line0, disp.line1, disp.line2, disp.line3 {=
      static char buf0[17];
      static char buf1[17];
      static char buf2[17];
      static char buf3[17];
      snprintf(buf0, 17, "EXTRA MODE");
      snprintf(buf1, 17, " ");
      snprintf(buf2, 17, " ");
      snprintf(buf3, 17, "Main Menu: [C]");
      lf_set(disp.line0, buf0);
      lf_set(disp.line1, buf1);
      lf_set(disp.line2, buf2);
      lf_set(disp.line3, buf3);
    =}

    //Checking buttons
    reaction(buttons.button_a, buttons.button_b, buttons.button_c) -> MAIN_MENU_MODE, motor.left_power, motor.right_power {=
      if (buttons.button_c->value) {
        lf_set(motor.left_power, 0);
        lf_set(motor.right_power, 0);
        lf_set_mode(MAIN_MENU_MODE);
      } 
    =}
  }

}
