/**
 * Drives the Pololu 3pi+ 2040 Robot using lines on the ground as guidance. 
 * It uses two lines spaced apart to check if there is drift by using line sensors. 
 * and then corrects itself by rotating the wheel respectively.
 * This iteration uses feedback with the motors so it can turn.
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Line from "lib/Line.lf"
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  
  main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
    line = new Line()
    disp = new Display()
    motor = new Motors()
  
    timer t(0, sample_period)
    timer seconds(0, 1 s)
    timer end_calibration(calibration_time)
    state count: int = 0
  
    timer backup(0, 500 ms)
  
  
    reaction(seconds) -> disp.line3 {=
    static char buf[17];
    snprintf(buf, 17, "time:%8d s", self->count++);
    lf_set(disp.line3, buf);
    =}
  
    reaction(end_calibration) -> line.calibrate, motor.left_power, motor.right_power {=
    lf_set(line.calibrate, false);
    lf_set(motor.left_power, 0.10f);
    lf_set(motor.right_power, 0.10f);
    =}
  
    reaction(t) -> line.trigger {=
    lf_set(line.trigger, true);
    =}
  
    initial mode DRIVE {
        reaction(line.reflect) -> motor.left_power, motor.right_power{= 
            //Drives using the line on the ground as reference
  
            /* Motor feedback to stay on the correct path */
            //If the left side of the line sensors are detected, we shift the robot right
            if (line.reflect->value[0] >= 800) {
              //Rotating wheels right to adjust to the right
              lf_set(motor.left_power, 0.15f);
              lf_set(motor.right_power, 0.10f);
            } 
  
            //If the right side of the line sensors are detected, we shift the robot left
            if (line.reflect->value[4] >= 800) {
              //Rotate the wheel left
              lf_set(motor.left_power, 0.10f);
              lf_set(motor.right_power, 0.15f);
            } 
        =} 
        
  
    }
  
    mode STOP_DETECTED {
        reaction(backup) -> DRIVE, motor.left_power, motor.right_power {=
            lf_set(motor.left_power, 0.0f);
            lf_set(motor.right_power, 0.0f);
            lf_set_mode(DRIVE);
        =}
    }
  
  
    reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, "CALIBRATING");
      lf_set(disp.line1, "Roll robot over");
      lf_set(disp.line2, "light and dark.");
      
    =}
  
    reaction(line.reflect) -> disp.line0, disp.line1, disp.line2 {=
      static char buf0[17];
      static char buf1[17];
      static char buf2[17];
      if (line.reflect->value[0] >= 1000) {
        snprintf(buf0, 17, "Right");
      } else {
        snprintf(buf0, 17, " ");
      }
      if (line.reflect->value[2] >= 1000) {
        snprintf(buf1, 17, "Center");
      } else { 
        snprintf(buf1, 17, " ");
      }
      if (line.reflect->value[4] >= 1000) {
        snprintf(buf2, 17, "Left.");
      } else { 
        snprintf(buf2, 17, " ");
      }
      lf_set(disp.line0, buf0);
      lf_set(disp.line1, buf1);
      lf_set(disp.line2, buf2);
    =}
  }
  